MODULE RNL_E_IO(SYSMODULE)

    !This module wraps the standard IO methods with datapointers

    !ERRNUM codes
    VAR errnum ERR_NOT_A_SIGNAL:=-1;
    VAR errnum ERR_SIGNAL_NOT_SUPPORTED:=-1;

    !Sets an IO
    PROC setIO(dataPointer signal,num value\num Delay|switch Sync)
        VAR signaldi ALIAS_di;
        VAR signaldo ALIAS_do;
        VAR signalai ALIAS_ai;
        VAR signalao ALIAS_ao;
        VAR signalgi ALIAS_gi;
        VAR signalgo ALIAS_go;
        VAR string signalName;
        
        BookErrNo ERR_NOT_A_SIGNAL;
        BookErrNo ERR_SIGNAL_NOT_SUPPORTED;

        TEST signal.type

        CASE type(ALIAS_di):
            RAISE ERR_SIGNAL_NOT_SUPPORTED;
        CASE type(ALIAS_do):
            signalName:=signal.name;
            AliasIO signalName,ALIAS_do;
            SetDO\SDelay?Delay,\Sync?Sync,ALIAS_do,value;

        CASE type(ALIAS_ai):
            RAISE ERR_SIGNAL_NOT_SUPPORTED;
        CASE type(ALIAS_ao):
            IF Present(Delay) OR Present(Sync) RAISE ERR_INVALID_ARGUMENTS;
            signalName:=signal.name;
            AliasIO signalName,ALIAS_ao;
            SetAO ALIAS_ao,value;

        CASE type(ALIAS_gi):
            RAISE ERR_SIGNAL_NOT_SUPPORTED;
        CASE type(ALIAS_go):
            IF Present(Sync) RAISE ERR_INVALID_ARGUMENTS;
            signalName:=signal.name;
            AliasIO signalName,ALIAS_go;
            SetGO\SDelay?Delay,ALIAS_go,value;

        DEFAULT:
            RAISE ERR_NOT_A_SIGNAL;
        ENDTEST

    ERROR
        RAISE ;
    ENDPROC

    !Gets an IO
    FUNC num getIO(dataPointer signal)
        VAR signaldi ALIAS_di;
        VAR signaldo ALIAS_do;
        VAR signalai ALIAS_ai;
        VAR signalao ALIAS_ao;
        VAR signalgi ALIAS_gi;
        VAR signalgo ALIAS_go;
        VAR string signalName;
        
        BookErrNo ERR_NOT_A_SIGNAL;
        BookErrNo ERR_SIGNAL_NOT_SUPPORTED;

        TEST signal.type

        CASE type(ALIAS_di):
            signalName:=signal.name;
            AliasIO signalName,ALIAS_di;
            RETURN DInput(ALIAS_di);

        CASE type(ALIAS_do):
            signalName:=signal.name;
            AliasIO signalName,ALIAS_do;
            RETURN DOutput(ALIAS_do);

        CASE type(ALIAS_ai):
            signalName:=signal.name;
            AliasIO signalName,ALIAS_ai;
            RETURN AInput(ALIAS_ai);

        CASE type(ALIAS_ao):
            signalName:=signal.name;
            AliasIO signalName,ALIAS_ao;
            RETURN AOutput(ALIAS_ao);

        CASE type(ALIAS_gi):
            signalName:=signal.name;
            AliasIO signalName,ALIAS_gi;
            RETURN GInput(ALIAS_gi);

        CASE type(ALIAS_go):
            signalName:=signal.name;
            AliasIO signalName,ALIAS_go;
            RETURN GOutput(ALIAS_go);

        DEFAULT:
            RAISE ERR_NOT_A_SIGNAL;
        ENDTEST

    ERROR
        RAISE ;
    ENDFUNC

    !Pulses an IO
    PROC pulseIO(dataPointer signal\switch High\num Lenght)

        VAR signaldo ALIAS_do;
        VAR string signalName;
        
        BookErrNo ERR_NOT_A_SIGNAL;
        BookErrNo ERR_SIGNAL_NOT_SUPPORTED;

        IF NOT dataPointer_isIO(signal) RAISE ERR_NOT_A_SIGNAL;
        IF signal.type<>type(ALIAS_do) RAISE ERR_SIGNAL_NOT_SUPPORTED;

        signalName:=signal.name;
        AliasIO signalName,ALIAS_do;

        PulseDO\High?High\PLength?Lenght,ALIAS_do;

    ENDPROC

ENDMODULE