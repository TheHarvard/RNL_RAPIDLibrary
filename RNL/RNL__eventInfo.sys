MODULE RNL__eventInfo(SYSMODULE)

    !This is the reference for all datatype/object modules. 
    !To create a new datatype copy this module and ctrl+f replace
    !"eventInfo" With the new datatype, set the NULL value to a value
    !that will never be in use, and adjust the list{X} size

    !Datatype: eventInfo
    !Module with standard methods for the datatype

    !***************************************************************************
    ! Data
    !***************************************************************************

    RECORD eventInfo
        event triggerEvent;
        dataPointer triggerObject;

        dataPointer data;
        unixTime timestamp;
    ENDRECORD

    !Per module setting for whether the list should be used
    !IF this bool is set to false (default) then the NEW keyword will
    !will create a stirng value datapointer for this datatype.
    !If it is set to true, then the NEW keyword will use the pre declared list.
    LOCAL CONST bool USE_LIST:=TRUE;

    !INHERITS_FROM is the type that this type inherits from.
    ! "" signifies no inheritance
    LOCAL CONST dataType INHERITS_FROM:="";

    !Null constants
    CONST eventInfo eventInfo_NULL:=[[0],["","",0,"","",0,""],["","",0,"","",0,""],0];
    LOCAL CONST eventInfo NULL:=[[0],["","",0,"","",0,""],["","",0,"","",0,""],0];

    !Pre delcared list to be dynamically allocated
    LOCAL VAR eventInfo list{100};
    LOCAL VAR num list_lenght:=0;

    !###########################################################################
    ! NEW Constructor and ERASE Destructor
    !###########################################################################

    !Allocate a data and return pointer
    LOCAL PROC NEW(INOUT dataPointer pointer\dataPointer self)
        VAR eventInfo data;
        VAR dataPointer self_;
        VAR dataPointer inheritanceParent;
        VAR dataPointer inheritanceParent_Pointer;

        self_:=pointer;
        IF Present(self) self_:=self;

        IF USE_LIST THEN
            !Allocate a list position
            pointer.type:=Type(list);
            LIST_eventInfo_append list\lenght:=list_lenght,data\index:=pointer.id;

            IF NOT INHERITS_FROM="" THEN
                !Create nessesary inheritance chain
                inheritanceParent:=NEW_(INHERITS_FROM);
                inheritanceParent_Pointer := NEW_("dataPointer");
                dataPointer_set inheritanceParent_Pointer,inheritanceParent;
                pointer.inheritanceParent_id := inheritanceParent_Pointer.id;
                pointer.inheritanceParent_name := inheritanceParent_Pointer.name;
            ENDIF

        ELSE
            !Create a string value datatype
            pointer:=eventInfo_(eventInfo_NULL);
        ENDIF
        
        ERROR
            RAISE ;
        ENDPROC

        !Resolve an RMQ_execute command for this datatype. Return result
        LOCAL PROC RMQ_execute(INOUT dataPointer pointer,VAR rmqmessage message)
            VAR eventInfo data;
            RMQGetMsgData message,data;

            !Add custom behavior for "executing" this datatype here
            pointer:=dataPointer_NULL;

        ERROR
            RAISE ;
        ENDPROC

        !Allocate a data, set the data to recived RMQ message, and return pointer
        LOCAL PROC RMQ_NEW(INOUT dataPointer pointer,VAR rmqmessage message)

            VAR eventInfo data;
            RMQGetMsgData message,data;

            IF USE_LIST THEN
                NEW pointer;
                eventInfo_set pointer,data;
                RETURN ;
            ENDIF

            pointer:=eventInfo_(data);

        ERROR
            RAISE ;
        ENDPROC

        !Send RMQ message of this datatype
        LOCAL PROC RMQ_send(INOUT dataPointer data,dataPointer queue,dataPointer code)
            VAR eventInfo data_;
            VAR string queue_;
            VAR num code_;

            VAR rmqslot slot;

            data_:=eventInfo_get(data);
            queue_:=string_get(queue);
            code_:=num_get(code);

            rmqfindslot slot,queue_;
            RMQSendMessage slot,data_\UserDef:=code_;

        ERROR
            RAISE ;
        ENDPROC

        !Cleans up any datapointer
        LOCAL PROC ERASE(INOUT dataPointer pointer)
            
            VAR dataPointer inheritanceParent;
            
            !Call ERASE on the object that this object inherits from
            IF pointer.inheritanceParent_name <> ""
            OR pointer.inheritanceParent_id > 0 THEN
                inheritanceParent.id := pointer.inheritanceParent_id;
                inheritanceParent.name := pointer.inheritanceParent_name;
                
                ERASE_ inheritanceParent;
            ENDIF
            
            !ERASE
            IF dataPointer_isReference(pointer) eventInfo_set pointer,NULL;
            IF dataPointer_isIndex(pointer) LIST_eventInfo_del list\lenght:=list_lenght,pointer.id;
            pointer:=dataPointer_NULL;
            
        ERROR
            RAISE ;
        ENDPROC

        !///////////////////////////////////////////////////////////////////////////
        ! Privat Data Methods
        !///////////////////////////////////////////////////////////////////////////

        !¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
        ! WRAPPER Methods
        !¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

        !===========================================================================
        ! Public Data/Object Methods
        !===========================================================================

        !---------------------------------------------------------------------------
        ! Auxiliary Methods
        !---------------------------------------------------------------------------

        !&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
        ! Getter and Setter Methods
        !&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        ! Standardized Methods
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%% DataPointer methods %%%%

        !Set a datapointers value
        PROC eventInfo_set(INOUT dataPointer pointer,eventInfo value)
        IF dataPointer_isReference(pointer) SetDataVal pointer.name,value;
        IF dataPointer_isReference(pointer) RETURN;
        IF dataPointer_isValue(pointer) pointer.value:=ValToStr(value);
        IF dataPointer_isValue(pointer) RETURN;
        IF dataPointer_isIndex(pointer) list{pointer.id}:=value;
        IF dataPointer_isIndex(pointer) RETURN;
        !ERROR
        !Data Pointer Not set up
        errno_bookAndRaise ERR_BAD_DATA_POINTER;
        ERROR
            RAISE ;
        ENDPROC

        !Get a datapointers value
        FUNC eventInfo eventInfo_get(dataPointer pointer)
            VAR eventInfo returnValue;
            returnValue:=NULL;
            IF dataPointer_isReference(pointer) GetDataVal pointer.name,returnValue;
            IF dataPointer_isValue(pointer) errFromBool StrToVal(pointer.value,returnValue),ERR_SYM_ACCESS;
            IF dataPointer_isIndex(pointer) returnValue:=list{pointer.id};
            RETURN returnValue;
        ERROR
            RAISE ;
        ENDFUNC

        !Create a value-datapointer from a value, or that points to a value
        FUNC dataPointer eventInfo_(eventInfo value\switch asReference)
            VAR dataPointer pointer;
            pointer.type:=Type(value);
            IF Present(asReference) pointer.name:=ArgName(value);
            IF NOT Present(asReference) pointer.value:=ValToStr(value);
            RETURN pointer;
        ERROR
            RAISE ;
        ENDFUNC

        ! %%%% LIST methods %%%%

        !Initialize new list
        PROC LIST_eventInfo_NEW(
        INOUT eventInfo list{*}
        \INOUT num lenght)

            FOR i FROM 1 TO Dim(list,1) DO
                list{i}:=NULL;
            ENDFOR

            lenght:=0;

        ENDPROC

        !Append a datapointer to the list
        !The optional argument index will be set to the index that was used
        PROC LIST_eventInfo_append(
        INOUT eventInfo list{*}
        \INOUT num lenght,
        eventInfo item
        \INOUT num index)

            IF NOT Present(lenght) THEN
                FOR i FROM 1 TO Dim(list,1) DO
                    IF list{i}=NULL THEN
                        list{i}:=item;
                        IF Present(index) index:=i;
                        RETURN ;
                    ENDIF
                ENDFOR
                RETURN ;
            ENDIF

            lenght:=lenght+1;
            list{lenght}:=item;
            IF present(index) index:=lenght;

        ERROR
            RAISE ;
        ENDPROC

        !Pop the last data pointer in the list
        !Or if index is specified, pops the index
        FUNC eventInfo LIST_eventInfo_pop(
        INOUT eventInfo list{*}
        \INOUT num lenght,
        \num index)

            VAR eventInfo item;

            !Pop at spesific index
            IF Present(index) THEN
                item:=list{index};
                list{index}:=NULL;
                LIST_eventInfo_del list\lenght?lenght,index;
                RETURN item;
            ENDIF

            !Pop at last index, without lenght
            IF NOT Present(lenght) THEN
                FOR i FROM Dim(list,1) TO 1 DO
                    IF list{i}<>NULL THEN
                        item:=list{i};
                        list{i}:=NULL;
                        RETURN item;
                    ENDIF
                ENDFOR
            ENDIF

            !Pop at last index, with lenght
            item:=list{lenght};
            list{lenght}:=NULL;
            lenght:=lenght-1;
            RETURN item;

        ERROR
            RAISE ;
        ENDFUNC

        !Delete an item at a position of the list
        PROC LIST_eventInfo_del(
        INOUT eventInfo list{*}
        \INOUT num lenght,
        num index)

            list{index}:=NULL;

            !Shift down the above items to close gap, without lenght
            IF NOT Present(lenght) THEN
                FOR i FROM index TO Dim(list,1)-1 DO
                    list{index}:=list{index+1};
                ENDFOR
                list{Dim(list,1)}:=NULL;
                RETURN ;
            ENDIF

            !Shift down the above items to close gap, with lenght
            FOR i FROM index TO lenght-1 DO
                list{index}:=list{index+1};
            ENDFOR
            list{lenght}:=NULL;

        ERROR
            RAISE ;
        ENDPROC

        !Returns the number of items actively used in the list
        FUNC num LIST_eventInfo_lenght(INOUT eventInfo list{*})
            VAR num lenght;
            lenght:=0;

            FOR i FROM 1 TO Dim(list,1) DO
                IF list{i}<>NULL THEN
                    lenght:=lenght+1;
                ENDIF
            ENDFOR

            RETURN lenght;
        ERROR
            RAISE ;
        ENDFUNC

        !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
        ! Examples
        !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

    ENDMODULE