MODULE RNL_E_RQM(SYSMODULE)

    !This module manages RQM

    ! proc try - send execute instruction and wait for Reply
    ! func RMQ_Start - send execute instruction
    ! func RMQ_Wait - wait execute instruction for Reply
    !
    !
    !

    ! This config needs to be set up in the roobot conf.
    !  -Name "T_ROB1" -Type "NORMAL" -MotionTask  -RmqType "Remote"\
    !  -RmqMode "Synchronous" -RmqMaxMsgSize 3000 -RmqMaxNoOfMsg 10


    ALIAS string rmqQueue;

    !The RMQ code is sen along RMQ messages, and consists of a total of 15 bits.
    !The highest 2 bits signify the instruction (rmqCode_Instruction)
    !The lower 13 bit signify a uniqe identifier (id) for the spesific instriction (rmqCode_id)
    ALIAS num rmqCode;
    ALIAS num rmqCode_Instruction;
    ALIAS num rmqCode_id;

    CONST rmqQueue rmqQueue_NULL:="";


    !Instructions are different kinds of RMQ messages that do different things:
    !Call event with recived data (event determined by code ID)
    CONST rmqCode_Instruction rmq_inst_EVENT:=0;
    !Execute the recived data (handeled differently for each data)
    CONST rmqCode_Instruction rmq_inst_EXECUTE:=1;
    !Allocate recived data (call the NEW keyword and return the datapointer)
    CONST rmqCode_Instruction rmq_inst_ALLOCATE:=2;
    !This is a response to an instruction, and not an instruction
    CONST rmqCode_Instruction rmq_inst_RESPONSE:=3;

    !Data used to generate uniqe rmqCode_id
    CONST rmqCode_id rmqCode_id_MAX:=8191;
    PERS rmqCode_id rmqCode_id_LAST:=1;
    CONST rmqCode_id rmqCode_id_MIN:=1;

    !ERRORS
    VAR errnum ERR_RMQ_BAD_INSTRUCTION:=-1;

    !Local RMQ queue (longer than the global queue)
    LOCAL VAR rmqLocalMessage LocalRMQQueue{500};
    LOCAL VAR num LocalRMQQueue_lenght:=0;

    PROC RMQ_event(rmqQueue queue,event e,\dataPointer data)

    ENDPROC

    PROC RMQ_executeQueuedMessages()

        !Empty queue into local queue
        RMQ_bufferToLocalQueue;

        !Loop through and handle all messages
        WHILE RMQ_handleNextMessage() DO
            RMQ_bufferToLocalQueue;
        ENDWHILE

    ENDPROC


    !Handles the next message in the queue
    FUNC bool RMQ_handleNextMessage()

        VAR rmqLocalMessage localMessage;
        VAR dataPointer rmqPointer;
        VAR bool successFlag;
        VAR event e;

        VAR bool pendingReply:=FALSE;
        VAR dataPointer responseData;


        !Check if any EXECUTE or EVENT instructions are in the queue
        localMessage:=RMQ_queue_popNextExecuteOrEvent(\successFlag:=successFlag);

        IF successFlag=TRUE THEN

            IF localMessage.instruction=rmq_inst_EVENT THEN

                !Get the source
                rmqPointer.rmqLocation:=localMessage.queue;

                !Execute the event instruction 
                e.id:=localMessage.id;
                TRIGGER\object:=rmqPointer,e\data:=localMessage.data;
            ENDIF

            IF localMessage.instruction=rmq_inst_EXECUTE THEN
                !Execute the execute instruction
                if localMessage.id<>0 pendingReply:=TRUE;
                try\obj:=localMessage.data,"RMQ_execute"\trowError;

                !Send reply
                IF pendingReply THEN
                    RMQ_send
                        localMessage.data,
                        localMessage.queue,
                        get_rmqcode(rmq_inst_RESPONSE,localMessage.id);
                    pendingReply:=FALSE;
                ENDIF

                !Clean up pointer
                ERASE_ localMessage.data;
            ENDIF

            RETURN TRUE;
        ENDIF

        RETURN FALSE;


    ERROR
        !In case of an error, send a response containing the error
        IF pendingReply THEN
            responseData:=NEW_errInfo();
            RMQ_send
                responseData,
                localMessage.queue,
                get_rmqcode(rmq_inst_RESPONSE,localMessage.id);
            ERASE responseData;
            pendingReply:=FALSE;

            !Clean up pointer
            ERASE_ localMessage.data;

            RETURN TRUE;
        ENDIF

    UNDO
        !In case of an undo, send an empty response
        IF pendingReply THEN
            RMQ_send
                localMessage.data,
                localMessage.queue,
                get_rmqcode(rmq_inst_RESPONSE,localMessage.id);
            pendingReply:=FALSE;

            !Clean up pointer
            ERASE_ localMessage.data;

        ENDIF

    ENDFUNC


    !Send
    PROC rmqLocalMessage_send(rmqLocalMessage localMessage)

        VAR rmqCode code;

        code:=get_rmqcode(localMessage.instruction,localMessage.id);

        try\obj:=localMessage.data,"RMQ_send"
        \arg1:=string_(localMessage.queue)
        \arg2:=num_(code)
        \trowError;
    ENDPROC


    !Returns true if the spesified response is in the local queue
    LOCAL FUNC bool RMQ_queue_hasResponse(rmqCode_id responseID,\INOUT num index)
        IF LocalRMQQueue_lenght>0 THEN
            FOR i FROM 1 TO LocalRMQQueue_lenght DO
                IF LocalRMQQueue{i}.instruction=rmq_inst_RESPONSE
            AND LocalRMQQueue{i}.id=responseID THEN
                    IF Present(index) index:=i;
                    RETURN TRUE;
                ENDIF
            ENDFOR
        ENDIF
        RETURN FALSE;
    ENDFUNC


    !Returns true if the spesified response is in the local queue
    LOCAL FUNC rmqLocalMessage RMQ_queue_popNextEvent(\INOUT bool successFlag)
        VAR rmqLocalMessage nextEvent;
        IF Present(successFlag) successFlag:=FALSE;
        IF LocalRMQQueue_lenght>0 THEN
            FOR i FROM 1 TO LocalRMQQueue_lenght DO
                IF LocalRMQQueue{i}.instruction=rmq_inst_EVENT THEN
                    nextEvent:=LIST_rmqLocalMessage_pop(
                    LocalRMQQueue
                    \lenght:=LocalRMQQueue_lenght
                    \index:=i);
                    IF Present(successFlag) successFlag:=TRUE;
                    RETURN nextEvent;
                ENDIF
            ENDFOR
        ENDIF
        RETURN rmqLocalMessage_NULL;
    ENDFUNC

    !Returns true if the spesified response is in the local queue
    LOCAL FUNC rmqLocalMessage RMQ_queue_popNextExecute(\INOUT bool successFlag)
        VAR rmqLocalMessage nextEvent;
        IF LocalRMQQueue_lenght>0 THEN
            IF Present(successFlag) successFlag:=FALSE;
            FOR i FROM 1 TO LocalRMQQueue_lenght DO
                IF LocalRMQQueue{i}.instruction=rmq_inst_EXECUTE THEN
                    nextEvent:=LIST_rmqLocalMessage_pop(
                    LocalRMQQueue
                    \lenght:=LocalRMQQueue_lenght
                    \index:=i);
                    IF Present(successFlag) successFlag:=FALSE;
                    RETURN nextEvent;
                ENDIF
            ENDFOR
        ENDIF
        RETURN rmqLocalMessage_NULL;
    ENDFUNC

    !Returns true if the spesified response is in the local queue
    LOCAL FUNC rmqLocalMessage RMQ_queue_popNextExecuteOrEvent(\INOUT bool successFlag)
        VAR rmqLocalMessage nextEvent;
        IF Present(successFlag) successFlag:=FALSE;
        IF LocalRMQQueue_lenght>0 THEN
            FOR i FROM 1 TO LocalRMQQueue_lenght DO
                IF LocalRMQQueue{i}.instruction=rmq_inst_EXECUTE
            OR LocalRMQQueue{i}.instruction=rmq_inst_EVENT THEN
                    nextEvent:=LIST_rmqLocalMessage_pop(
                    LocalRMQQueue
                    \lenght:=LocalRMQQueue_lenght
                    \index:=i);
                    IF Present(successFlag) successFlag:=TRUE;
                    RETURN nextEvent;
                ENDIF
            ENDFOR
        ENDIF
        RETURN rmqLocalMessage_NULL;
    ENDFUNC

    !buffer the RMQ queue, and move it into the LocalRMQQueue
    PROC RMQ_bufferToLocalQueue()

        VAR rmqmessage message;
        VAR rmqheader header;
        VAR rmqslot slot;
        VAR rmqCode code;
        VAR rmqLocalMessage localMessage;

        VAR bool NEW_failed:=FALSE;
        VAR rmqCode responseCode;

        VAR errorData errData;

        WHILE TRUE DO

            !Pop the topmost message from the global queue
            !OR, if no message, go to ERROR handler (ERRNO=ERR_RMQ_TIMEOUT) and return 
            !This is effectively the cycle time allowing each task to yield for each other
            RMQReadWait message\TimeOut:=0.1;


            !Get header
            RMQGetMsgHeader message
            \header:=header
            \SenderId:=slot
            \UserDef:=code;

            localMessage.header:=header;

            !Get sender
            localMessage.queue:=RMQGetSlotName(slot);


            TPWrite "Recived "+NumToStr(code,0);

            !Get code(s)
            localMessage.instruction:=get_rmqCode_Instruction(code);
            localMessage.id:=get_rmqCode_id(code);

            !Check for ID collisions, and skip ahead if too close
            !(Assumes that the id codes are used in order on both ends)
            IF localMessage.id<rmqCode_id_LAST+100
            AND localMessage.id>rmqCode_id_LAST-100 THEN
                rmqCode_id_LAST:=rmqCode_id_LAST+500;
            ENDIF

            !Allocate and save data
            IF header.datatype="" THEN
                !No datatype given
                localMessage.data:=dataPointer_NULL;

            ELSEIF header.datatype=Type(dataPointer_NULL) THEN
                RMQGetMsgData message,localMessage.data;

            ELSE
                localMessage.data:=NEW_(header.datatype\RMQ_message:=message);
            ENDIF

            IF NEW_failed THEN
                !IF the NEW command failed, return failure data to sender

                responseCode:=get_rmqcode(rmq_inst_RESPONSE,localMessage.id);
                RMQSendMessage slot,errData\UserDef:=responseCode;

            ELSEIF localMessage.instruction=rmq_inst_ALLOCATE THEN
                !IF the instruction was an allocate instruction, then we can
                !Reply now

                responseCode:=get_rmqcode(rmq_inst_RESPONSE,localMessage.id);
                RMQSendMessage slot,localMessage.data\UserDef:=responseCode;

            ELSE
                !Otherwise we need to add this local message to the local queue

                LIST_rmqLocalMessage_append
                LocalRMQQueue
                \lenght:=LocalRMQQueue_lenght,
                localMessage;

            ENDIF

            !Add logging here for logging all incoming RMQ traffic

            !Clean up stale replies.
            IF LocalRMQQueue_lenght>(Dim(LocalRMQQueue,1)-10) THEN
                ErrWrite "LocalRMQQueue is almost full","Cleaning up first 20% of old responses to make space"
                \RL2:="Check if the program is reciving replies it is not expecting";
                FOR i FROM 1 TO Dim(LocalRMQQueue,1) DIV 5 DO
                    IF LocalRMQQueue{i}.instruction=rmq_inst_RESPONSE THEN
                        LIST_rmqLocalMessage_del LocalRMQQueue\lenght:=LocalRMQQueue_lenght,i;
                    ENDIF
                ENDFOR
            ENDIF

        ENDWHILE

    ERROR

        IF ERRNO=ERR_RMQ_TIMEOUT THEN
            !Queue is empty
            SkipWarn;
            RETURN ;
        ENDIF

        IF ERRNO=ERR_BAD_DATA_TYPE THEN
            !Incoming datatype is invalid
            SkipWarn;
            NEW_failed:=TRUE;
            TRYNEXT;
        ENDIF

        RAISE ;
    ENDPROC


    !RMQ code

    FUNC rmqCode get_rmqcode(rmqCode_Instruction instruction,rmqCode_id id)
        RETURN (instruction*8192)+id;
    ENDFUNC

    FUNC rmqCode_Instruction get_rmqCode_Instruction(rmqCode code)
        RETURN DnumToNum(BitRShDnum(NumToDnum(code),13));
    ENDFUNC

    FUNC rmqCode_id get_rmqCode_id(rmqCode code)
        RETURN code-(get_rmqCode_Instruction(code)*8192);
    ENDFUNC


    !RMQ Start and Wait

    !Send a RMQ instruction, and get a id that can be used to wait for the response
    FUNC rmqCode_id RMQ_start(
        rmqQueue queue,
        dataPointer data
        \switch allocate
        \switch skipResponse,
        \switch sendAsPointer,
        \switch cleanUpPointer)

        VAR rmqCode_id id;
        VAR rmqCode_Instruction instruction;
        VAR rmqCode code;

        VAR bool successFlag:=FALSE;
        VAR rmqslot slot;

        !Create ID
        IF Present(skipResponse) THEN
            id:=0;
        ELSE
            id:=rmqCode_id_generate();
        ENDIF

        !Set instruction
        instruction:=rmq_inst_EXECUTE;
        IF Present(allocate) instruction:=rmq_inst_ALLOCATE;

        code:=get_rmqcode(instruction,id);

        !Call RMQ send method on this spesific datatype
        IF NOT Present(sendAsPointer) THEN
            try\obj:=data,"RMQ_send"
            \arg1:=string_(queue)
            \arg2:=num_(code)
            \successFlag:=successFlag;
        ENDIF

        !sendAsPointer - send data as pointer
        !OR failed to call RMQ_send method, Try to send directly as datapointer
        IF Present(sendAsPointer)
        OR (successFlag=FALSE AND dataPointer_isValue(data)) THEN
            rmqfindslot slot,queue;
            RMQSendMessage slot,data\UserDef:=code;
            successFlag:=TRUE;
        ENDIF

        !Cleanup
        IF Present(cleanUpPointer) THEN
            !ERASE the pointer
            ERASE_ data;
            data:=dataPointer_NULL;
        ENDIF

        IF successFlag=TRUE THEN
            RETURN id;
        ELSE
            !ERROR
        ENDIF


    ENDFUNC

    !Wait for a spesific RMQ response
    FUNC dataPointer RMQ_wait(
        rmqCode_id responseID,
        \switch exclusive
        \num maxTime
        \INOUT bool TimeFlag)

        VAR rmqLocalMessage localMessage;
        VAR num index;

        VAR clock waitClock;
        ClkStart waitClock;

        IF Present(TimeFlag) TimeFlag:=FALSE;

        !Wait until response arrives
        WHILE TRUE DO

            !Check if reply is ready
            IF RMQ_queue_hasResponse(responseID\index:=index) THEN
                localMessage:=LIST_rmqLocalMessage_pop(
                LocalRMQQueue,
                \lenght:=LocalRMQQueue_lenght,
                \index:=index);
                RETURN localMessage.data;
            ENDIF

            !Check if timeout
            IF Present(maxTime) THEN
                IF ClkRead(waitClock)>maxTime THEN
                    IF Present(TimeFlag) THEN
                        TimeFlag:=TRUE;
                        RETURN dataPointer_NULL;
                    ELSE
                        RAISE ERR_WAIT_MAXTIME;
                    ENDIF
                ENDIF
            ENDIF

            !            !Call main to process other incoming events
            !            !Or if exclusive is included, then just buffer the RMQ queue
            !            IF NOT Present(exclusive) THEN
            !                RNL_main;
            !            ELSE
            RMQ_bufferToLocalQueue;
            !            ENDIF

        ENDWHILE

    ENDFUNC



    PROC RMQ_send_(INOUT dataPointer data,dataPointer queue,dataPointer code)
        RMQ_send data,string_get(queue),num_get(code);
    ENDPROC

    PROC RMQ_send(INOUT dataPointer data,rmqQueue queue,rmqCode code)
        try\obj:=data,"RMQ_send"
            \arg1:=string_(queue)
            \arg2:=num_(code)
            \trowError;
    ENDPROC


    FUNC rmqCode_id rmqCode_id_generate()
        IF rmqCode_id_LAST>rmqCode_id_MAX rmqCode_id_LAST:=rmqCode_id_MIN+(rmqCode_id_LAST-rmqCode_id_MAX);
        rmqCode_id_LAST:=rmqCode_id_LAST+1;
        IF rmqCode_id_LAST>rmqCode_id_MAX rmqCode_id_LAST:=rmqCode_id_MIN;
        RETURN rmqCode_id_LAST;
    ENDFUNC


    FUNC rmqQueue rmqQueue_SELF()
        RETURN "RMQ_"+GetTaskName();
    ENDFUNC

    FUNC dataPointer rmqObject(rmqQueue queue)
        VAR datapointer pointer;
        pointer.rmqLocation:=queue;
        RETURN pointer;
    ENDFUNC


ENDMODULE