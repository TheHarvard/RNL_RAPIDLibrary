MODULE RNL__gripper_PRototype(SYSMODULE)

!    !This is the reference for all datatype/object modules. 
!    !To create a new datatype copy this module and ctrl+f replace
!    !"gripper" With the new datatype, set the NULL value to a value
!    !that will never be in use, and adjust the list{X} size.


!    !Datatype: gripper
!    !Module with standard methods for the datatype

!    !***************************************************************************
!    ! Data
!    !***************************************************************************

!    RECORD gripper
!        dataPointer self;

!        string lastFunction;

!        gripper_function function1;
!        gripper_function function2;
!        gripper_function function3;
!        gripper_function function4;
!        gripper_function function5;
!        gripper_function function6;
!        gripper_function function7;
!        gripper_function function8;
!        gripper_function function9;
!        gripper_function function10;

!    ENDRECORD

!    RECORD gripper_function
!        string name;
!        num maxTime;
!        dataPointer di_normal;
!        dataPointer di_inverted;
!        dataPointer di_fault;
!        dataPointer do_normal;
!        dataPointer do_inverted;
!    ENDRECORD

!    CONST errnum ERR_GRIPPER_BAD_SIGNAL:=-1;
!    CONST errnum ERR_GRIPPER_MISSING_SIGNAL:=-1;
!    CONST errnum ERR_GRIPPER_FAULT_SIGNAL:=-1;

!    !A constant that can be searched for to determine if a datatype module is loaded
!    PERS dataType dataType_gripper:="gripper";

!    !Per module setting for whether the list should be used
!    !IF this bool is set to false then the NEW keyword will
!    !will create a stirng value datapointer for this datatype.
!    !If it is set to true, then the NEW keyword will use the pre declared list.
!    LOCAL CONST bool USE_DYNAMIC_DATA_ALLOCATION:=TRUE;

!    !INHERITS_FROM is the type that this type inherits from.
!    ! "" signifies no inheritance
!    LOCAL CONST dataType INHERITS_FROM:="";

!    !Null constants
!    CONST gripper gripper_NULL:=[["","",0,"","",0,""],0,0,0];
!    LOCAL CONST gripper gripper_DEFAULT:=[["","",0,"","",0,""],0,0,0];

!    !Pre declared list to be dynamically allocated
!    LOCAL VAR gripper list{200};
!    !LOCAL VAR num list_lenght:=0;

!    !###########################################################################
!    ! NEW Constructor and ERASE Destructor
!    !###########################################################################

!    !NEW constructor with initial values
!    FUNC dataPointer NEW_gripper(
!        \num exampleNumber1
!        \num exampleNumber2
!        \num exampleNumber3
!        )
!        VAR dataPointer pointer;
!        VAR gripper data;

!        !Allocate and set data
!        NEW pointer;

!        !Set initial data 
!        data:=gripper_get(pointer);

!        !Data without any setter function here
!        !(Only for datatypes without inheritance)
!        IF Present(exampleNumber1) data.exampleNumber1:=exampleNumber1;
!        IF Present(exampleNumber2) data.exampleNumber2:=exampleNumber2;
!        IF Present(exampleNumber3) data.exampleNumber3:=exampleNumber3;

!        gripper_set pointer,data;

!        !Data with setter functions here:

!        !Present(exampleNumber1) setExampleNumber1 pointer exampleNumber1
!        !Present(exampleNumber2) setExampleNumber2 pointer exampleNumber2
!        !Present(exampleNumber3) setExampleNumber3 pointer exampleNumber3

!        !Return pointer
!        RETURN pointer;
!    ENDFUNC

!    !NEW constructor to allocate a data and return pointer
!    LOCAL PROC NEW(INOUT dataPointer pointer\dataPointer self)
!        VAR gripper data;
!        VAR dataPointer self_;
!        VAR dataPointer inheritanceParent;
!        VAR dataPointer inheritanceParent_Pointer;

!        self_:=pointer;
!        IF Present(self) self_:=self;

!        data:=gripper_DEFAULT;
!        data.self:=self_;

!        IF USE_DYNAMIC_DATA_ALLOCATION=TRUE THEN

!            !Set the rmqLocation to this task
!            pointer.rmqLocation:=rmqQueue_SELF();

!            !Allocate a list position
!            pointer.type:=Type(list);
!            LIST_gripper_append list,data\index:=pointer.id;

!            IF NOT INHERITS_FROM="" THEN
!                !Create nessesary inheritance chain
!                inheritanceParent:=NEW_(INHERITS_FROM);
!                inheritanceParent_Pointer:=NEW_("dataPointer");
!                pointer.inheritanceParent_id:=inheritanceParent_Pointer.id;
!                pointer.inheritanceParent_name:=inheritanceParent_Pointer.name;
!            ENDIF

!        ELSE

!            !Create a string value datatype
!            pointer:=gripper_(data);
!        ENDIF


!    ERROR
!        !RAISE ;
!    ENDPROC

!    !Resolve an RMQ_execute command for this datatype. Return result
!    LOCAL PROC RMQ_execute(INOUT dataPointer pointer,VAR rmqmessage message)
!        VAR gripper data;
!        RMQGetMsgData message,data;

!        !Add custom behavior for "executing" this datatype here
!        pointer:=dataPointer_NULL;

!    ERROR
!        !RAISE ;
!    ENDPROC

!    !Allocate a data, set the data to recived RMQ message, and return pointer
!    LOCAL PROC RMQ_NEW(INOUT dataPointer pointer,VAR rmqmessage message)

!        VAR gripper data;
!        RMQGetMsgData message,data;

!        IF USE_DYNAMIC_DATA_ALLOCATION=TRUE THEN
!            NEW pointer;
!            gripper_set pointer,data;
!            RETURN ;
!        ENDIF

!        pointer:=gripper_(data);

!    ERROR
!        !RAISE ;
!    ENDPROC

!    !Send RMQ message of this datatype
!    LOCAL PROC RMQ_send(INOUT dataPointer data,dataPointer queue,dataPointer code)
!        VAR gripper data_;
!        VAR string queue_;
!        VAR num code_;

!        VAR rmqslot slot;

!        data_:=gripper_get(data);
!        queue_:=string_get(queue);
!        code_:=num_get(code);

!        RMQFindSlot slot,queue_;
!        RMQSendMessage slot,data_\UserDef:=code_;

!    ERROR
!        !RAISE ;
!    ENDPROC

!    !Cleans up any datapointer
!    LOCAL PROC ERASE(INOUT dataPointer pointer)

!        VAR dataPointer inheritanceParent;

!        !Call ERASE on the object that this object inherits from
!        IF pointer.inheritanceParent_name<>""
!            OR pointer.inheritanceParent_id>0 THEN
!            inheritanceParent.id:=pointer.inheritanceParent_id;
!            inheritanceParent.name:=pointer.inheritanceParent_name;

!            ERASE_ inheritanceParent;
!        ENDIF

!        !ERASE
!        IF dataPointer_isReference(pointer) gripper_set pointer,gripper_NULL;
!        IF dataPointer_isIndex(pointer) LIST_gripper_del list\keepIndexes,pointer.id;
!        pointer:=dataPointer_NULL;

!    ERROR
!        !RAISE ;
!    ENDPROC


!    !¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
!    ! WRAPPER Methods
!    !¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

!    !¤¤¤ set Function ¤¤¤

!    PROC gripper_setFunction_(dataPointer pointer,
!        string name,
!        \dataPointer di_normal,
!        \dataPointer di_inverted,
!        \dataPointer di_fault,
!        \dataPointer do_normal,
!        \dataPointer do_inverted
!        \num maxTime)

!        VAR dataPointer di_normal_;
!        VAR dataPointer di_inverted_;
!        VAR dataPointer di_fault_;
!        VAR dataPointer do_normal_;
!        VAR num maxTime_;

!        IF Present(di_normal) di_normal_:=di_normal;
!        IF Present(di_inverted_) di_inverted_:=di_inverted;
!        IF Present(di_fault_) di_fault_:=di_fault;
!        IF Present(do_normal_) do_normal_:=do_normal;
!        IF Present(maxTime_) maxTime_:=maxTime;

!        try\obj:=pointer,"setFunction"
!        \arg1:=string_(name)
!        \arg2:=di_normal_
!        \arg3:=di_inverted_
!        \arg4:=di_fault_
!        \arg5:=num_(maxTime_);

!    ENDPROC

!    PROC gripper_setOpen_(dataPointer pointer,\dataPointer di_normal,\dataPointer di_inverted,\dataPointer di_fault,\dataPointer do_normal,\dataPointer do_inverted,\num maxTime)
!        gripper_setFunction_ pointer,"open"\di_normal?di_normal\di_inverted?di_inverted,\di_fault?di_fault,\do_normal?do_normal,\do_inverted?do_inverted\maxTime?maxTime;
!    ENDPROC

!    PROC gripper_setClose_(dataPointer pointer,\dataPointer di_normal,\dataPointer di_inverted,\dataPointer di_fault,\dataPointer do_normal,\dataPointer do_inverted,\num maxTime)
!        gripper_setFunction_ pointer,"close"\di_normal?di_normal\di_inverted?di_inverted,\di_fault?di_fault,\do_normal?do_normal,\do_inverted?do_inverted\maxTime?maxTime;
!    ENDPROC

!    PROC gripper_setOn_(dataPointer pointer,\dataPointer di_normal,\dataPointer di_inverted,\dataPointer di_fault,\dataPointer do_normal,\dataPointer do_inverted,\num maxTime)
!        gripper_setFunction_ pointer,"on"\di_normal?di_normal\di_inverted?di_inverted,\di_fault?di_fault,\do_normal?do_normal,\do_inverted?do_inverted\maxTime?maxTime;
!    ENDPROC

!    PROC gripper_setOff_(dataPointer pointer,\dataPointer di_normal,\dataPointer di_inverted,\dataPointer di_fault,\dataPointer do_normal,\dataPointer do_inverted,\num maxTime)
!        gripper_setFunction_ pointer,"off"\di_normal?di_normal\di_inverted?di_inverted,\di_fault?di_fault,\do_normal?do_normal,\do_inverted?do_inverted\maxTime?maxTime;
!    ENDPROC

!    !¤¤¤ do Function ¤¤¤

!    PROC gripper_doFunction_(dataPointer pointer,string name)
!        try\obj:=pointer,"doFunction"\arg1:=string_(name);
!    ENDPROC



!    !¤¤¤ is Function ¤¤¤
!    PROC gripper_isFunction_(dataPointer pointer,string name)
!        try\obj:=pointer,"isFunction"\arg1:=string_(name);
!    ENDPROC


!    !===========================================================================
!    ! Public Data/Object Methods
!    !===========================================================================

!    !=== setup ans use functions ===
!    LOCAL PROC setFunction(dataPointer pointer,dataPointer name)
!        VAR gripper object;
!        object:=gripper_get(pointer);
!        <SMT>
!    ENDPROC

!    LOCAL PROC executeFunction(dataPointer pointer,dataPointer name)
!        VAR gripper object;
!        object:=gripper_get(pointer);
!        <SMT>
!    ENDPROC


!    !---------------------------------------------------------------------------
!    ! Auxiliary Methods
!    !---------------------------------------------------------------------------

!    !///////////////////////////////////////////////////////////////////////////
!    ! Privat Data/Object Methods
!    !///////////////////////////////////////////////////////////////////////////

!    !/// get a indexed gripper_function ///
!    FUNC gripper_function gripper_getGripperFunction(gripper object,num i)
!        TEST i
!        CASE 1:
!            RETURN object.function1;
!        CASE 2:
!            RETURN object.function2;
!        CASE 3:
!            RETURN object.function3;
!        CASE 4:
!            RETURN object.function4;
!        CASE 5:
!            RETURN object.function5;
!        CASE 6:
!            RETURN object.function6;
!        CASE 7:
!            RETURN object.function7;
!        CASE 8:
!            RETURN object.function8;
!        CASE 9:
!            RETURN object.function9;
!        CASE 10:
!            RETURN object.function10;

!        DEFAULT:
!            !ERROR
!            errno_bookAndRaise ERR_INDEX_OUT_OF_RANGE;
!        ENDTEST

!    ERROR
!        RAISE ;
!    ENDFUNC

!    !/// set a indexed gripper_function ///
!    PROC gripper_setGripperFunction(INOUT gripper object,num i,gripper_function item)
!        TEST i
!        CASE 1:
!            object.function1:=item;
!        CASE 2:
!            object.function2:=item;
!        CASE 3:
!            object.function3:=item;
!        CASE 4:
!            object.function4:=item;
!        CASE 5:
!            object.function5:=item;
!        CASE 6:
!            object.function6:=item;
!        CASE 7:
!            object.function7:=item;
!        CASE 8:
!            object.function8:=item;
!        CASE 9:
!            object.function9:=item;
!        CASE 10:
!            object.function10:=item;
!        DEFAULT:
!            !ERROR
!            errno_bookAndRaise ERR_INDEX_OUT_OF_RANGE;
!        ENDTEST

!    ERROR
!        RAISE ;
!    ENDPROC


!    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!    ! Event Responses
!    !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!    ! States
!    !$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

!    !&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
!    ! Getter and Setter Methods
!    !&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

!    !&&& Get Self &&&
!    LOCAL PROC getSelf(dataPointer pointer,INOUT datapointer self)
!        VAR gripper object;
!        object:=gripper_get(pointer);
!        self:=object.self;
!    ENDPROC

!    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!    ! Standardized Methods
!    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

!    !%%%% Initialize the list %%%%

!    !Initialize the list
!    LOCAL PROC init()
!        LIST_gripper_clear list;
!    ENDPROC

!    !%%%% Direct Access to list %%%%

!    !Allow acces to list
!    FUNC gripper gripper_list(num i)
!        RETURN list{i};
!    ENDFUNC

!    !Allow access to list lenght
!    FUNC num gripper_lenght()
!        !RETURN list_lenght;
!        RETURN LIST_gripper_lenght(list);
!    ENDFUNC

!    !%%%% Event Handler %%%%

!    !event_handler is the default target for events subscribed to this object
!    LOCAL PROC event_handler(dataPointer pointer,dataPointer eventNote)
!        !Add default event handeling here
!    ENDPROC

!    !%%%% DataPointer methods %%%%

!    !Set a datapointers value
!    PROC gripper_set(INOUT dataPointer pointer,gripper value)
!        IF dataPointer_isReference(pointer) SetDataVal pointer.name,value;
!        IF dataPointer_isReference(pointer) RETURN ;
!        IF dataPointer_isValue(pointer) pointer.value:=ValToStr(value);
!        IF dataPointer_isValue(pointer) RETURN ;
!        IF dataPointer_isIndex(pointer) list{pointer.id}:=value;
!        IF dataPointer_isIndex(pointer) RETURN ;
!        !If the pointer is none of the above, create a new pointer with string val
!        IF NOT USE_DYNAMIC_DATA_ALLOCATION pointer:=gripper_(value);
!        IF NOT USE_DYNAMIC_DATA_ALLOCATION RETURN ;
!        !ERROR
!        !Data Pointer Not set up
!        errno_bookAndRaise ERR_BAD_DATA_POINTER;
!    ERROR
!        !RAISE ;
!    ENDPROC

!    !Get a datapointers value
!    FUNC gripper gripper_get(dataPointer pointer)
!        VAR gripper returnValue;
!        returnValue:=gripper_NULL;
!        IF dataPointer_isReference(pointer) GetDataVal pointer.name,returnValue;
!        IF dataPointer_isValue(pointer) errFromBool StrToVal(pointer.value,returnValue),ERR_SYM_ACCESS;
!        IF dataPointer_isIndex(pointer) returnValue:=list{pointer.id};
!        RETURN returnValue;
!    ERROR
!        !RAISE ;
!    ENDFUNC

!    !Method for to create a value-datapointer from a value, or that points to a value
!    FUNC dataPointer gripper_(gripper value\switch asReference)
!        VAR dataPointer pointer;
!        pointer.type:=Type(value);
!        IF Present(asReference) pointer.name:=ArgName(value);
!        IF NOT Present(asReference) pointer.value:=ValToStr(value);
!        RETURN pointer;
!    ERROR
!        !RAISE ;
!    ENDFUNC

!    ! %%%% LIST methods %%%%

!    !Initialize new list
!    PROC LIST_gripper_clear(
!        INOUT gripper list{*}
!        \INOUT num lenght)

!        FOR i FROM 1 TO Dim(list,1) DO
!            list{i}:=gripper_NULL;
!        ENDFOR

!        IF Present(lenght) lenght:=0;

!    ENDPROC

!    !Append a datapointer to the list
!    !The optional argument index will be set to the index that was used
!    PROC LIST_gripper_append(
!        INOUT gripper list{*}
!        \INOUT num lenght,
!        gripper item
!        \INOUT num index)

!        !Reject null input
!        IF item=gripper_NULL errno_bookAndRaise(ERR_UNEXPECTED_NULL);

!        IF NOT Present(lenght) THEN
!            FOR i FROM 1 TO Dim(list,1) DO
!                IF list{i}=gripper_NULL THEN
!                    list{i}:=item;
!                    IF Present(index) index:=i;
!                    RETURN ;
!                ENDIF
!            ENDFOR
!            RETURN ;
!        ENDIF

!        lenght:=lenght+1;
!        list{lenght}:=item;
!        IF Present(index) index:=lenght;

!    ERROR
!        !RAISE ;
!    ENDPROC

!    !Pop the last data pointer in the list
!    !Or if index is specified, pops the index
!    FUNC gripper LIST_gripper_pop(
!        INOUT gripper list{*}
!        \INOUT num lenght,
!        \num index)

!        VAR gripper item;

!        !Reject indexes ouside of lenght
!        IF Present(lenght) AND Present(index) THEN
!            IF index>lenght errno_bookAndRaise(ERR_LIST_OUT_OF_RANGE);
!        ENDIF

!        !Pop at spesific index
!        IF Present(index) THEN
!            item:=list{index};
!            list{index}:=gripper_NULL;
!            LIST_gripper_del list \lenght?lenght \keepIndexes,index;
!            RETURN item;
!        ENDIF

!        !Pop at last index, without lenght
!        IF NOT Present(lenght) THEN
!            FOR i FROM Dim(list,1) TO 1 DO
!                IF list{i}<>gripper_NULL THEN
!                    item:=list{i};
!                    list{i}:=gripper_NULL;
!                    RETURN item;
!                ENDIF
!            ENDFOR
!        ENDIF

!        !Pop at last index, with lenght
!        item:=list{lenght};
!        list{lenght}:=gripper_NULL;
!        lenght:=lenght-1;
!        RETURN item;

!    ERROR
!        !RAISE ;
!    ENDFUNC

!    !Delete an item at a position of the list
!    PROC LIST_gripper_del(
!        INOUT gripper list{*}
!        \INOUT num lenght
!        \switch keepIndexes,
!        num index)

!        !Reject indexes ouside of lenght
!        IF Present(lenght) AND Present(index) THEN
!            IF index>lenght errno_bookAndRaise(ERR_LIST_OUT_OF_RANGE);
!        ENDIF

!        !Delet data
!        list{index}:=gripper_NULL;

!        !If indexes should be keept, then don't shift any data around
!        IF Present(keepIndexes) RETURN ;

!        !Shift down the above items to close gap, without lenght
!        IF NOT Present(lenght) THEN
!            FOR i FROM index TO Dim(list,1)-1 DO
!                list{index}:=list{index+1};
!            ENDFOR
!            list{Dim(list,1)}:=gripper_NULL;
!            RETURN ;
!        ENDIF

!        !Shift down the above items to close gap, with lenght
!        FOR i FROM index TO lenght-1 DO
!            list{index}:=list{index+1};
!        ENDFOR
!        list{lenght}:=gripper_NULL;
!        lenght:=lenght-1;

!    ERROR
!        IF ERRNO=ERR_LIST_OUT_OF_RANGE RAISE ERR_LIST_OUT_OF_RANGE;
!        !RAISE ;
!    ENDPROC

!    !Returns the number of items actively used in the list (not null)
!    FUNC num LIST_gripper_lenght(INOUT gripper list{*})
!        VAR num lenght;
!        lenght:=0;

!        FOR i FROM 1 TO Dim(list,1) DO
!            IF list{i}<>gripper_NULL THEN
!                lenght:=lenght+1;
!            ENDIF
!        ENDFOR

!        RETURN lenght;
!    ERROR
!        !RAISE ;
!    ENDFUNC

!    !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
!    ! Examples
!    !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

ENDMODULE